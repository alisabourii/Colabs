# -*- coding: utf-8 -*-
"""Lecture8_Intro_OOP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/156a76aYGSx6Ef60cMQOoQHk4HiR6fL-i

# Nesne Yönelimli Programlamaya Giriş

Bu derste şunları ele alacağız:
Nesne Yönelimli Programlama (OOP): Sınıf ve nesnelerin oluşturulmasının temelleri

# OOP ve Classes

Kendimize ait, özelleştirilmiş nesne türlerini, belirli öznitelik (attribute) ve metot (method) kümeleriyle tanımlamayı öğreneceğiz. Bu sayede Python’ı nesne yönelimli (object-oriented) bir programlama dili olarak kullanmış olacağız.

Sınıflar (Classes), veri ve işlevselliği bir araya getirmeyi sağlar ve programlama sırasında ayrıntıları soyutlamanıza imkân tanır. Yeni bir sınıf oluşturmak, yeni bir nesne türü (type) oluşturmak anlamına gelir ve bu türden yeni örnekler (instances) yaratılmasına olanak sağlar. Her bir sınıf örneği, kendi durumunu (state) korumak için özniteliklere (attributes) sahip olabilir. Ayrıca sınıf örnekleri, durumlarını değiştirmek için (sınıf tarafından tanımlanan) metotlara (methods) da sahip olabilir.

Şimdi, “Animal” adlı bir sınıf tanımlayalım. Özel metot olan __init__, sınıfımız için örnek düzeyinde (instance-level) öznitelikleri tanımlamamıza olanak sağlar:
"""

class Animal:
    # constructor: __init__ method
    def __init__(self, sound):
        self.sound_attribute = sound
        print(f"An instance of Animal class with sound '{sound}' is created :-)")

    # method
    def make_sound(self):
        print(f"Making sound: {self.sound_attribute}!")

    def set_sound(self, newsound):
        self.sound_attribute = newsound

"""Bir sınıftan örnek (instance) nesneler oluşturma:



"""

cat = Animal(sound="Meow") # this is an instance
dog = Animal(sound="Bark")

"""Invoking `Animal()` actually calls `__init__()` “under the hood” and creates an instance. Any argument that we feed to `Animal()` gets passed to `__init__`. The first argument `self` in `__init__` refers to the object instance of the class that is being created.

`Animal()` çağrısı aslında perde arkasında (under the hood) `__init__()` metodunu çağırır ve bir örnek (instance) oluşturur. `Animal()`'a verdiğimiz tüm argümanlar `__init__` metoduna aktarılır.
`__init__` içindeki ilk argüman olan self, oluşturulmakta olan sınıfın nesne örneğini ifade eder.

Bir nesnenin belirli bir sınıfın/türün örneği (instance) olup olmadığını görmek için:
"""

isinstance(cat, Animal), isinstance(dog, Animal)

type(cat), type(dog)

isinstance([1,2,3], list)

cat.sound_attribute, dog.sound_attribute

dog.set_sound("Woof")

print(dog.sound_attribute)

cat.make_sound()
dog.make_sound()

duck = Animal("")

duck.set_sound("Quack")

duck.make_sound()

"""## Sınıf metotları ve örnek (instance) metotları

Python, örnek (instance) nesneyi ifade etmek için  `self` parametresini kullanır:
- Bir örnek, sınıfına ait bir metodu çağırdığında, metot ilk argüman olarak otomatik biçimde o örnek nesnenin referansını alır.
- `instance.method(args) = class.method(instance,args)`
- `self`, Python’da bir gelenektir (konvansiyon). Zorunlu olarak  `self` adı verilmesi gerekmez; ancak Python topluluğunda yaygın ve yerleşik kullanım  `self`'tir.
"""

# instance.method(args) = class.method(instance,args)
print("Call class method: class.method(instance,args):\n")
Animal.make_sound(cat)
Animal.make_sound(dog)

print("\nCall instance method: instance.method(args):\n")
cat.make_sound()
dog.make_sound()

"""Sınıf metodu (class method) ve örnek metodu (instance method) gösteren daha fazla örnek:"""

x = [] # Instance from the list class is typically created via syntax []
x.append(1)  # instance.method(args)
x

y = list() # You can also uses list() to create the list class
list.append(y, 1)  # class.method(instance, args)
y.append(2)
y

"""## Sınıflar ve nesneler kullanmanın faydaları (örnek: banka hesabı)

Banka hesabı örneği:
Diyelim ki bir banka kartı (debit) hesabım ve bir de kredi kartı (credit) hesabım var…
"""

debits = []
credits = []

def add_to_debits(debits_list, value):
    debits_list.append(value)

def add_to_credits(credits_list, value):
    credits_list.append(value)

add_to_debits(debits, 10)
add_to_debits(debits, 15)
add_to_debits(debits, 100)

add_to_credits(credits, 100)

print(f"Check my debits: {debits}")
print(f"Check my credits: {credits}")

"""Net değer nedir? (Varlık)"""

def total_value(debits, credits):
    total = 0
    for val in debits:
        total += val
    for val in credits:
        total -= val
    return total

total_net_worth = total_value(debits, credits)
print(f"The total net worth is {total_net_worth}.")

"""Problem: Ölçeklenebilir değil!
Ya 100 kullanıcımız olursa? Ya her kullanıcının bir de hesaba (saving account)” ihtiyacı olursa?
Sınıfların bu noktada nasıl yardımcı olabileceğine bakalım.

Bir class initialize edelim
"""

class Account:
    def __init__(self):
        self.debits = []
        self.credits = []

a1 = Account()
print(a1.debits)
print(a1.credits)

a2 = Account()
print(a2.debits)
print(a2.credits)

"""Method ekle"""

class Account:
    # a class attributes
    __accounts__ = []

    def __init__(self, name):
        # instance attributes
        self.name = name
        self.debits = []
        self.credits = []
        self.saving = []

        # store all existing user account to a shared class attribute
        Account.__accounts__ += [self]

    def add_to_credits(self, value):
        self.credits.append(value)

    def add_to_debits(self, value):
        self.debits.append(value)

    def total_value(self) -> int | float:
        total = 0
        total += sum(self.debits)
        total -= sum(self.credits)
        return total

    def get_all_accounts(): # no self
        return Account.__accounts__

w = Account("user0")

w.name

a1 = Account(name='user1')
a2 = Account(name='user2')

print(f"a1.credits:{a1.credits}")
print(f"a2.credits:{a2.credits}\n")

a1.add_to_credits(10)

print(f"a1.credits:{a1.credits}")
print(f"a2.credits:{a2.credits}")

a1.add_to_debits(40)
a2.add_to_debits(40)

print(f"a1.debits:{a1.debits}")
print(f"a2.debits:{a2.debits}")

print(f"a1 total value:{a1.total_value()}")

print(f"a2 total value:{a2.total_value()}")

Account.__accounts__

a1.__accounts__

res = Account.get_all_accounts()
res

# Go over each instance
for i in range(len(res)):
  print(res[i].name)

Account.get_all_accounts()

"""###  Alıştırma 1 (Derste) – Account sınıfına işlevsellik ekleme
###  Account sınıfına daha fazla işlevsellik ekleyin
1. Hesaptan para çıkışı (credit) yapılmadan önce, yeterli bakiye olup olmadığını kontrol edin (toplam değer her zaman negatif olmamalıdır). İşlem geçerliyse True, değilse False döndürün.

2. Account sınıfına bir `transfer` fonksiyonu ekleyin. Bu fonksiyon, bir hesaptan diğerine para transferi yapsın. Bir hesabın debit listesine ekleme yaparken, diğer hesabın credit listesine ekleme yapmalıdır.
"""

# Solution:
class Account:
    accounts = []

    def __init__(self):
        self.debits = []
        self.credits = []
        Account.accounts += [self]

    def add_to_credits(self, value):
        if value <= self.total_value():
            self.credits.append(value)
            return True
        else:
            print("Insufficinent funds")
            return False

    def add_to_debits(self, value):
        self.debits.append(value)

    def total_value(self):
        self.guess = "Take a guess"
        total = 0
        total += sum(self.debits)
        total -= sum(self.credits)
        return total

    def transfer(self, other, value):
        if self.add_to_credits(value):
            other.add_to_debits(value)

# Test Code:
a1 = Account()
a2 = Account()
a1.add_to_credits(10)
a1.add_to_debits(40)
a2.add_to_debits(10)

print(f"a1 total value:{a1.total_value()}")
print(f"a2 total value:{a2.total_value()}")

a1.transfer(a2, 10)

print(f"a1 total value:{a1.total_value()}")
print(f"a2 total value:{a2.total_value()}")

a2.transfer(a1, 30)
